// Copright (c) 2013 Tijmen van der Burgt
// Use of this source code is governed by the MIT license,
// that can be found in the LICENSE file.

// Package passgen provides several cryptographicaly secure pseudorandom
// pass{word,phrase} generator methods.
package passgen

import (
	"bufio"
	"bytes"
	"crypto/rand"
	"encoding/base32"
	"encoding/hex"
	"errors"
	"io"
	"math"
	"math/big"
	"os"
	"strings"
	"unicode"
)

// CharSet represents the set of printable ASCII characters.
// The maximum number of characters is 95. All printable characters are
// available in the continuous range of [32,126].
type CharSet uint8

const (
	// Bitmask flags for creating a permutation of characters sets.
	SetLower    CharSet = 1 << iota       // Lower case letters [a-z]
	SetUpper                              // Upper case letters [A-Z]
	SetDigit                              // Decimal digits [0-9]
	SetPunct                              // Punctuation chars [!"#%&'()*,-./:;?@[\]_{}]
	SetSymbol                             // Symbolic chars [$+<=>^`|~]
	SetSpace                              // White space char
	SetComplete CharSet = (1 << iota) - 1 // Set of all printable chars
)

var (
	ErrLength = errors.New("passgen: invalid password length")
	ErrSet    = errors.New("passgen: character set is empty")

	charSets = [...]string{
		"abcdefghijklmnopqrstuvwxyz",
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ",
		"0123456789",
		`!"#%&'()*,-./:;?@[\]_{}`,
		"$+<=>^`|~",
		" ",
	}
)

// Reader is a global instance of a random reader, used by the random password
// generator functions in this package. Reader defaults to the cryptographically
// secure pseudorandom generator in crypto/rand.
var Reader io.Reader = rand.Reader

// Base32Alphabet is the encoding alphabet used by the base32 generator
// function. Base32Alphabet defaults to base32.StdEncoding (see RFC 4648).
var Base32Alphabet *base32.Encoding = base32.StdEncoding

// Dictionary file to be used by the diceware method.
var DicewareDict = "/usr/share/dict/words"

// Cardinality returns the charset Size.
func (set CharSet) Cardinality() (c int) {
	for i, s := range charSets {
		if set&(1<<CharSet(i)) != 0 {
			c += len(s)
		}
	}
	return
}

func (set CharSet) table() []byte {
	table := make([]byte, 0, set.Cardinality())
	for i, s := range charSets {
		if set&(1<<CharSet(i)) != 0 {
			table = append(table, []byte(s)...)
		}
	}
	return table
}

func readRandomBytes(buf []byte) error {
	n := 0

	// Keep reading random bytes until buffer is filled
	for n < len(buf) {
		if m, err := Reader.Read(buf); err != nil {
			return err
		} else {
			n += m
		}
	}

	return nil
}

// Ascii generates a uniformly distributed random ASCII string with length n.
// The password space consists of printable ASCII chars and can be narrowed down
// with the CharSet bitmask s.
func Ascii(n int, s CharSet) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	if s == 0 {
		return nil, ErrSet
	}

	var shiftSize uint
	table := s.table()
	pass := make([]byte, n)

	// Determine maximum shift size that minimizes the random bytes' range,
	// while exceeding the cardinality of the set of permissable characters.
	for max := math.MaxUint8 >> 1; max >= len(table)-1; max >>= 1 {
		shiftSize++
	}

	for i := 0; i < n; {
		// Generate remaining random bytes
		if err := readRandomBytes(pass[i:]); err != nil {
			return nil, err
		}

		// Process batch of generated bytes in range [i:n)
		for _, b := range pass[i:] {
			// Minimize range
			b >>= shiftSize

			// If byte size exceeds cardinality, discard it.
			// Otherwise, select corresponding char from table.
			if int(b) < len(table) {
				pass[i] = table[b]
				i++
			}
		}
	}
	return pass, nil
}

// Hex generates a uniformly distributed random hex string (base16) with length n.
func Hex(n int) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	// Add additional byte if length is odd (hex encoding works with
	// multiples of 2 bytes)
	m := n + n%2

	src := make([]byte, hex.DecodedLen(m)) // Random bytes
	dst := make([]byte, m)                 // Hexadecimal bytes

	if err := readRandomBytes(src); err != nil {
		return nil, err
	}

	hex.Encode(dst, src)

	return dst[:n], nil
}

// Base32 generates a uniformly distributed random base32 string with length n.
func Base32(n int) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	m := n
	// Clamp length to nearest multiple of 8 (base32 encoding works with
	// multiples of 8 bytes)
	if offset := m % 8; offset != 0 {
		m += 8 - offset
	}

	src := make([]byte, Base32Alphabet.DecodedLen(m))
	dst := make([]byte, m)

	if err := readRandomBytes(src); err != nil {
		return nil, err
	}

	Base32Alphabet.Encode(dst, src)

	return dst[:n], nil
}

// Dicware selects n random words from the specified dictionary file (DicewareDict).
// Words can be separated with the sep string (usually "" or " ").
// Aside from the generated passphrase, the dictionary size m (i.e. number of
// selectable words) is returned. This can be useful for determining the
// entropy of the resulting passphrase (See the Entropy function).
func Diceware(n int, sep string) (phrase []byte, m int, err error) {
	dict, err := os.Open(DicewareDict)
	if err != nil {
		return
	}

	// Copy all dictionary words to a slice
	var words []string
	scanner := bufio.NewScanner(dict)
	for scanner.Scan() {
		w := scanner.Text()
		// Apply crude word filtering
		switch {
		// Empty line
		case len(w) == 0:
			break
		// Plural format
		case strings.HasSuffix(w, "'s"):
			break
		// Starts with capital
		case unicode.IsUpper(rune(w[0])):
			break
		default:
			words = append(words, scanner.Text())
			m++
		}
	}
	if scanner.Err() != nil {
		return
	}

	max := big.NewInt(int64(m))
	var pos *big.Int
	var buffer bytes.Buffer
	for i := 0; i < n; i++ {
		if pos, err = rand.Int(Reader, max); err != nil {
			return
		}
		if i > 0 {
			buffer.WriteString(sep)
		}
		buffer.WriteString(words[int(pos.Int64())])
	}

	phrase = buffer.Bytes()
	return
}

// Entropy calculates password strength (in bits) of a password with length n,
// selected from a set of m possible symbols.
func Entropy(n, m int) float64 {
	return float64(n) * math.Log2(float64(m))
}
