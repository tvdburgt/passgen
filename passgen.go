package passgen

import (
	"crypto/rand"
	"encoding/hex"
	"errors"
	"math"
)

// CharSet represents a set of printable ASCII characters.
// The maximum number of characters is 95. All printable characters are
// available in the continuous range of [32,126].
type CharSet uint8

const (
	// Bitmask flags for creating a permutation of characters sets.
	SetLower    CharSet = 1 << iota       // Lower case letters [a-z]
	SetUpper                              // Upper case letters [A-Z]
	SetDigit                              // Decimal digits [0-9]
	SetPunct                              // Punctuation chars [!"#%&'()*,-./:;?@[\]_{}]
	SetSymbol                             // Symbolic chars [$+<=>^`|~]
	SetSpace                              // White space char
	SetComplete CharSet = (1 << iota) - 1 // Set of all printable chars
)

var (
	// Instance of random source reader. Defaults to Reader from crypto/rand.
	Reader = rand.Reader

	ErrLength = errors.New("passgen: invalid password length")
	ErrSet    = errors.New("passgen: character set is empty")

	charSets = [...]string{
		"abcdefghijklmnopqrstuvwxyz",
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ",
		"0123456789",
		`!"#%&'()*,-./:;?@[\]_{}`,
		"$+<=>^`|~",
		" ",
	}
)

func (set CharSet) cardinality() (c int) {
	for i, s := range charSets {
		if set&(1<<CharSet(i)) != 0 {
			c += len(s)
		}
	}
	return
}

func (set CharSet) table() []byte {
	table := make([]byte, 0, set.cardinality())
	for i, s := range charSets {
		if set&(1<<CharSet(i)) != 0 {
			table = append(table, []byte(s)...)
		}
	}
	return table
}

// Generates a uniform password by reading random bytes from Reader.
// The password space can be defined with the CharSet parameter s.
func Generate(n int, s CharSet) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	if s == 0 {
		return nil, ErrSet
	}

	var shiftSize uint
	table := s.table()
	pass := make([]byte, n)

	// Determine maximum shift size that minimizes the random bytes' range,
	// while exceeding the cardinality of the set of permissable characters.
	for max := math.MaxUint8 >> 1; max >= len(table)-1; max >>= 1 {
		shiftSize++
	}

	for i := 0; i < n; {
		// Generate remaining random bytes
		if _, err := Reader.Read(pass[i:]); err != nil {
			return nil, err
		}

		// Process batch of generated bytes in range [i:n)
		for _, b := range pass[i:] {
			// Minimize range
			b >>= shiftSize

			// If byte size exceeds cardinality, discard it.
			// Otherwise, select corresponding char from table.
			if int(b) < len(table) {
				pass[i] = table[b]
				i++
			}
		}
	}
	return pass, nil
}

// Generates a uniformly distributed hex string (base16) with length n.
func GenerateHex(n int) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	m := n
	// Add an additional byte if length is odd
	if n%2 != 0 {
		m = n + 1
	}

	src := make([]byte, hex.DecodedLen(m)) // Random bytes
	dst := make([]byte, m)                 // Hexadecimal bytes

	if _, err := Reader.Read(src); err != nil {
		return nil, err
	}

	hex.Encode(dst, src)

	return dst[:n], nil
}
