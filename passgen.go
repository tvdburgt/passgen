// Copright (c) 2013 Tijmen van der Burgt
// Use of this source code is governed by the MIT license,
// that can be found in the LICENSE file.

// Package passgen implements several fine-grained random password generator
// functions.
package passgen

import (
	"crypto/rand"
	"encoding/base32"
	"encoding/hex"
	"errors"
	"io"
	"math"
)

// CharSet represents a set of printable ASCII characters.
// The maximum number of characters is 95. All printable characters are
// available in the continuous range of [32,126].
type CharSet uint8

const (
	// Bitmask flags for creating a permutation of characters sets.
	SetLower    CharSet = 1 << iota       // Lower case letters [a-z]
	SetUpper                              // Upper case letters [A-Z]
	SetDigit                              // Decimal digits [0-9]
	SetPunct                              // Punctuation chars [!"#%&'()*,-./:;?@[\]_{}]
	SetSymbol                             // Symbolic chars [$+<=>^`|~]
	SetSpace                              // White space char
	SetComplete CharSet = (1 << iota) - 1 // Set of all printable chars
)

var (
	ErrLength = errors.New("passgen: invalid password length")
	ErrSet    = errors.New("passgen: character set is empty")

	charSets = [...]string{
		"abcdefghijklmnopqrstuvwxyz",
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ",
		"0123456789",
		`!"#%&'()*,-./:;?@[\]_{}`,
		"$+<=>^`|~",
		" ",
	}
)

// Reader is a global instance of a random reader, used by the random password
// generator functions in this package. Reader defaults to the cryptographically
// secure pseudo-random generator in crypto/rand.
var Reader io.Reader = rand.Reader

// Base32Alphabet is the encoding alphabet used by the base32 generator
// function. Base32Alphabet defaults to base32.StdEncoding (see RFC 4648).
var Base32Alphabet *base32.Encoding = base32.StdEncoding

func (set CharSet) cardinality() (c int) {
	for i, s := range charSets {
		if set&(1<<CharSet(i)) != 0 {
			c += len(s)
		}
	}
	return
}

func (set CharSet) table() []byte {
	table := make([]byte, 0, set.cardinality())
	for i, s := range charSets {
		if set&(1<<CharSet(i)) != 0 {
			table = append(table, []byte(s)...)
		}
	}
	return table
}

// Generates a uniformly distributed random password with length n.
// The password space can be defined with the CharSet parameter s.
func Generate(n int, s CharSet) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	if s == 0 {
		return nil, ErrSet
	}

	var shiftSize uint
	table := s.table()
	pass := make([]byte, n)

	// Determine maximum shift size that minimizes the random bytes' range,
	// while exceeding the cardinality of the set of permissable characters.
	for max := math.MaxUint8 >> 1; max >= len(table)-1; max >>= 1 {
		shiftSize++
	}

	for i := 0; i < n; {
		// Generate remaining random bytes
		if _, err := Reader.Read(pass[i:]); err != nil {
			return nil, err
		}

		// Process batch of generated bytes in range [i:n)
		for _, b := range pass[i:] {
			// Minimize range
			b >>= shiftSize

			// If byte size exceeds cardinality, discard it.
			// Otherwise, select corresponding char from table.
			if int(b) < len(table) {
				pass[i] = table[b]
				i++
			}
		}
	}
	return pass, nil
}

// Generates a uniformly distributed random hex string (base16) with length n.
func GenerateHex(n int) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	// Add additional byte if length is odd (hex encoding works with
	// multiples of 2 bytes)
	m := n + n%2

	src := make([]byte, hex.DecodedLen(m)) // Random bytes
	dst := make([]byte, m)                 // Hexadecimal bytes

	if _, err := Reader.Read(src); err != nil {
		return nil, err
	}

	hex.Encode(dst, src)

	return dst[:n], nil
}

// Generates a uniformly distributed random base32 string with length n.
func GenerateBase32(n int) ([]byte, error) {
	if n <= 0 {
		return nil, ErrLength
	}

	m := n
	// Clamp length to nearest multiple of 8 (base32 encoding works with
	// multiples of 8 bytes)
	if offset := m % 8; offset != 0 {
		m += 8 - offset
	}

	src := make([]byte, Base32Alphabet.DecodedLen(m))
	dst := make([]byte, m)

	if _, err := Reader.Read(src); err != nil {
		return nil, err
	}

	Base32Alphabet.Encode(dst, src)

	return dst[:n], nil
}
